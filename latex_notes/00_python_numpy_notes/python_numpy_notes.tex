\documentclass{article}

% Language setting
% Replace `english' with e.g. `spanish' to change the document language
\usepackage[english]{babel}

% Set page size and margins
% Replace `letterpaper' with`a4paper' for UK/EU standard size
\usepackage[letterpaper,top=2cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}

% Useful packages
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}

\usepackage{xcolor}
\usepackage{listings}
\lstset{
  language=Python,
  basicstyle=\ttfamily\footnotesize,
  keywordstyle=\color{blue},
  stringstyle=\color{red},
  commentstyle=\color{gray},
  showstringspaces=false,
  breaklines=true,
  numbers=left,            % â† Line numbers on the left
  numberstyle=\tiny\color{gray}, % Style of line numbers
  numbersep=2pt            % Space between numbers and code
}

% Automatic Gapping after code snippits:
\usepackage{etoolbox}
\preto{\lstlisting}{\vspace{10pt}}
\appto{\endlstlisting}{\vspace{10pt}}


\title{Python and Latex Keynotes}
\author{Ramtin.B.A}

\begin{document}
\maketitle

% \begin{abstract}
% Your abstract.
% \end{abstract}

\section{Python}
\subsection{type hinting:}

These donâ€™t enforce types at runtime, but they:
\begin{itemize}
\item Help with readability.  
\item Enable better auto-completion and linting in editors like VS Code or PyCharm.
\item Make it easier for tools like mypy, Pyright, or Pylance to check for type correctness.
\end{itemize}

example of type hinting in older python versions:
\begin{lstlisting}
    class NN(MLP):
    def test(self, x_test, y_test):
        # expected x_test and y_test to be np.ndarray
        return some_float_value

\end{lstlisting}
  
modern examples:
\begin{lstlisting}
    def my_func(data: list[int]) -> dict[str, float]:
\end{lstlisting}
or:
\begin{lstlisting}
    def test(self, x_test: np.ndarray, y_test: np.ndarray) -> float:
\end{lstlisting}

This is just a function declaration inside a class, but with type annotations:

\begin{itemize}
    \item \texttt{x\_test: np.ndarray} â€“ This says that \texttt{x\_test} is expected to be a NumPy array.
    \item \texttt{y\_test: np.ndarray} â€“ Same for \texttt{y\_test}.
    \item \texttt{-> float} â€“ The function is expected to return a float.
\end{itemize}
  

\subsection{What is __call__}

If you define `__call__` in a class, it makes **instances of that class callable like functions**.

That means after creating an object, you can "call" it using `()` as if it were a regular function.

---

## ðŸ“Œ Basic Example

\begin{lstlisting}
class Greeter:
    def __init__(self, name):
        self.name = name

    def __call__(self, greeting):
        return f"{greeting}, {self.name}!"

g = Greeter("Alice")
print(g("Hello"))  # Output: Hello, Alice!
\end{lstlisting}

> ðŸ”Ž `g("Hello")` is equivalent to `g.__call__("Hello")`

---

## ðŸ§  When to Use `__call__`

| Use Case                         | Example                                            |
| -------------------------------- | -------------------------------------------------- |
| **Function objects**             | ML models, custom layers, or pipelines             |
| **Memoization / caching**        | Store previous calls and results                   |
| **Stateful function-like logic** | Functions that keep history, counters, etc.        |
| **DSL or APIs**                  | For making fluent interfaces or functional configs |

---

## ðŸ”¬ Practical Example (ML Style)

\begin{lstlisting}
class LinearModel:
    def __init__(self, w, b):
        self.w = w
        self.b = b

    def __call__(self, x):
        return self.w * x + self.b

model = LinearModel(2, 3)
print(model(5))  # Output: 13
\end{lstlisting}

Thatâ€™s just like doing:

\begin{lstlisting}
def linear(x):
    return 2 * x + 3
\end{lstlisting}

But now it's an **object with state**, which you can update, inspect, or reuse.

---

##Summary

* `__call__` lets you write `obj()` instead of `obj.__call__()`
* It's useful when you want **function-like objects** that also carry **internal state**.
* Common in **machine learning**, **decorators**, **fluent APIs**, and **function wrappers**.

---

Would you like an example combining `__call__` and `__init__` with a decorator-like use case or maybe for a neural network layer class?


\section{Numpy}

\end{document}